const PartMapping = require('../models/PartMapping');
const ProductTargetPart = require('../models/ProductTargetPart');
const ValidationService = require('./validationService');
const TargetPart = require('../models/TargetPart');

class ConfigurationGenerator {
  
  /**
   * 根据Product和TargetPart组合生成可用的硬件配置方案
   */
  async generateConfigurations(productId, targetPartIds) {
    try {
      const Product = require('../models/Product');
      const product = await Product.findById(productId);
      
      if (!product) {
        throw new Error('产品不存在');
      }
      
      const configurations = {
        product_id: productId,
        product_model: product.model,
        generation_date: new Date(),
        available_configurations: [],
        validation_summary: {
          total_combinations: 0,
          valid_combinations: 0,
          invalid_combinations: 0
        }
      };
      
      // 获取每个Target Part可用的Part映射
      const targetPartOptions = await this.getTargetPartOptions(targetPartIds);
      
      // 生成所有可能的组合
      const allCombinations = this.generateCombinations(targetPartOptions);
      
      configurations.validation_summary.total_combinations = allCombinations.length;
      
      // 验证每个组合
      for (const combination of allCombinations) {
        const validationResult = await this.validateConfiguration({
          product_id: productId,
          target_part_selections: combination
        });
        
        if (validationResult.overall_valid) {
          configurations.available_configurations.push({
            combination_id: this.generateCombinationId(combination),
            selections: combination,
            validation_result: validationResult,
            compatibility_score: this.calculateCompatibilityScore(validationResult),
            estimated_cost: await this.estimateCost(combination),
            reliability_score: this.calculateReliabilityScore(combination)
          });
          configurations.validation_summary.valid_combinations++;
        } else {
          configurations.validation_summary.invalid_combinations++;
        }
      }
      
      // 按兼容性分数排序
      configurations.available_configurations.sort((a, b) => 
        b.compatibility_score - a.compatibility_score
      );
      
      return configurations;
    } catch (error) {
      throw new Error(`生成配置失败: ${error.message}`);
    }
  }
  
  /**
   * 获取每个Target Part可用的Part选项
   */
  async getTargetPartOptions(targetPartIds) {
    const options = [];
    
    for (const targetPartId of targetPartIds) {
      const targetPart = await TargetPart.findById(targetPartId);
      
      // 如果启用了自动生成，则根据level1、level2和物理参数自动匹配
      if (targetPart.auto_generation_rules?.enabled) {
        const autoGeneratedParts = await this.autoGenerateParts(targetPart);
        
        options.push({
          target_part_id: targetPartId,
          available_parts: autoGeneratedParts,
          auto_generated: true
        });
      } else {
        // 使用原有的映射方式
        const partMappings = await PartMapping.find({ 
          target_part_id: targetPartId,
          validation_status: 'validated'
        }).populate('part_id');
        
        const validParts = [];
        
        for (const mapping of partMappings) {
          // 验证技术规格
          const validation = await ValidationService.validateTechnicalRequirements(
            mapping.part_id._id, 
            targetPartId
          );
          
          if (validation.overall_passed) {
            validParts.push({
              part_id: mapping.part_id._id,
              part_number: mapping.part_id.part_id,
              part_name: mapping.part_id.name,
              match_strength: mapping.match_strength,
              validation_result: validation
            });
          }
        }
        
        options.push({
          target_part_id: targetPartId,
          available_parts: validParts,
          auto_generated: false
        });
      }
    }
    
    return options;
  }
  
  /**
   * 根据level1、level2和物理参数自动生成零件选项
   */
  async autoGenerateParts(targetPart) {
    const Part = require('../models/Part');
    const { level1_category, level2_category, physical_parameters } = targetPart;
    
    // 构建查询条件
    const query = {
      status: 'active'
    };
    
    // 根据level1和level2分类匹配
    if (level1_category) {
      query.category = { $regex: level1_category, $options: 'i' };
    }
    
    // 根据物理参数范围匹配
    const physicalQueries = [];
    
    if (physical_parameters?.voltage_range) {
      physicalQueries.push({
        $or: [
          { spec: { $regex: `${physical_parameters.voltage_range.min}V`, $options: 'i' } },
          { spec: { $regex: `${physical_parameters.voltage_range.max}V`, $options: 'i' } },
          { spec: { $regex: 'voltage', $options: 'i' } }
        ]
      });
    }
    
    if (physical_parameters?.current_range) {
      physicalQueries.push({
        $or: [
          { spec: { $regex: `${physical_parameters.current_range.min}A`, $options: 'i' } },
          { spec: { $regex: `${physical_parameters.current_range.max}A`, $options: 'i' } },
          { spec: { $regex: 'current', $options: 'i' } }
        ]
      });
    }
    
    if (physical_parameters?.power_range) {
      physicalQueries.push({
        $or: [
          { spec: { $regex: `${physical_parameters.power_range.min}W`, $options: 'i' } },
          { spec: { $regex: `${physical_parameters.power_range.max}W`, $options: 'i' } },
          { spec: { $regex: 'power', $options: 'i' } }
        ]
      });
    }
    
    if (physical_parameters?.package_type) {
      physicalQueries.push({
        spec: { $regex: physical_parameters.package_type, $options: 'i' }
      });
    }
    
    if (physicalQueries.length > 0) {
      query.$and = physicalQueries;
    }
    
    // 查询匹配的零件
    const matchedParts = await Part.find(query).limit(10);
    
    // 转换为配置生成器需要的格式
    const autoGeneratedParts = matchedParts.map(part => ({
      part_id: part._id,
      part_number: part.part_id,
      part_name: part.name,
      match_strength: this.calculateAutoMatchStrength(part, targetPart),
      validation_result: {
        overall_passed: true,
        technical_validation: {
          voltage_compatible: true,
          current_compatible: true,
          power_compatible: true,
          package_compatible: true
        }
      },
      auto_generated: true
    }));
    
    return autoGeneratedParts;
  }
  
  /**
   * 计算自动匹配的强度
   */
  calculateAutoMatchStrength(part, targetPart) {
    let score = 0;
    const { physical_parameters } = targetPart;
    
    // 检查电压兼容性
    if (this.isVoltageCompatible(part.spec, physical_parameters?.voltage_range)) {
      score += 25;
    }
    
    // 检查电流兼容性
    if (this.isCurrentCompatible(part.spec, physical_parameters?.current_range)) {
      score += 25;
    }
    
    // 检查功率兼容性
    if (this.isPowerCompatible(part.spec, physical_parameters?.power_range)) {
      score += 25;
    }
    
    // 检查封装兼容性
    if (this.isPackageCompatible(part.spec, physical_parameters?.package_type)) {
      score += 25;
    }
    
    // 根据分数确定匹配强度
    if (score >= 90) return 'high';
    if (score >= 70) return 'medium';
    return 'low';
  }
  
  /**
   * 检查电压兼容性
   */
  isVoltageCompatible(partSpec, voltageRange) {
    if (!voltageRange) return true;
    
    // 简单的电压匹配逻辑（实际应用中需要更复杂的解析）
    const voltageRegex = /(\d+(\.\d+)?)\s*V/g;
    const matches = partSpec.match(voltageRegex);
    
    if (matches) {
      for (const match of matches) {
        const voltage = parseFloat(match);
        if (voltage >= voltageRange.min && voltage <= voltageRange.max) {
          return true;
        }
      }
    }
    
    return false;
  }
  
  /**
   * 检查电流兼容性
   */
  isCurrentCompatible(partSpec, currentRange) {
    if (!currentRange) return true;
    
    const currentRegex = /(\d+(\.\d+)?)\s*A/g;
    const matches = partSpec.match(currentRegex);
    
    if (matches) {
      for (const match of matches) {
        const current = parseFloat(match);
        if (current >= currentRange.min && current <= currentRange.max) {
          return true;
        }
      }
    }
    
    return false;
  }
  
  /**
   * 检查功率兼容性
   */
  isPowerCompatible(partSpec, powerRange) {
    if (!powerRange) return true;
    
    const powerRegex = /(\d+(\.\d+)?)\s*W/g;
    const matches = partSpec.match(powerRegex);
    
    if (matches) {
      for (const match of matches) {
        const power = parseFloat(match);
        if (power >= powerRange.min && power <= powerRange.max) {
          return true;
        }
      }
    }
    
    return false;
  }
  
  /**
   * 检查封装兼容性
   */
  isPackageCompatible(partSpec, packageType) {
    if (!packageType) return true;
    
    return partSpec.toLowerCase().includes(packageType.toLowerCase());
  }
  
  /**
   * 生成所有可能的组合
   */
  generateCombinations(targetPartOptions) {
    if (targetPartOptions.length === 0) return [];
    
    const combinations = [];
    
    // 使用递归生成所有组合
    const generate = (currentIndex, currentCombination) => {
      if (currentIndex === targetPartOptions.length) {
        combinations.push([...currentCombination]);
        return;
      }
      
      const currentOption = targetPartOptions[currentIndex];
      
      for (const part of currentOption.available_parts) {
        currentCombination.push({
          target_part_id: currentOption.target_part_id,
          selected_part_id: part.part_id,
          selected_part_id: part.part_id,
          match_strength: part.match_strength
        });
        
        generate(currentIndex + 1, currentCombination);
        
        currentCombination.pop();
      }
    };
    
    generate(0, []);
    
    return combinations;
  }
  
  /**
   * 验证单个配置
   */
  async validateConfiguration(configuration) {
    return await ValidationService.validateHardwareConfiguration(configuration);
  }
  
  /**
   * 生成组合ID
   */
  generateCombinationId(combination) {
    return combination.map(sel => 
      `${sel.target_part_id}_${sel.selected_part_id}`
    ).join('|');
  }
  
  /**
   * 计算兼容性分数
   */
  calculateCompatibilityScore(validationResult) {
    let score = 100;
    
    // 根据验证结果调整分数
    for (const selection of validationResult.selections) {
      const strength = selection.technical_validation.match_strength;
      switch (strength) {
        case 'high': score += 10; break;
        case 'medium': score += 5; break;
        case 'low': score -= 5; break;
      }
    }
    
    // 根据兼容性问题扣分
    score -= validationResult.compatibility_issues.length * 20;
    
    return Math.max(0, Math.min(100, score));
  }
  
  /**
   * 估算成本
   */
  async estimateCost(combination) {
    // 这里可以集成成本数据库或API
    // 暂时返回模拟数据
    const Part = require('../models/Part');
    let totalCost = 0;
    
    for (const selection of combination) {
      const part = await Part.findById(selection.selected_part_id);
      // 模拟成本计算逻辑
      const baseCost = 10; // 基础成本
      const strengthMultiplier = {
        'high': 1.2,
        'medium': 1.0,
        'low': 0.8
      }[selection.match_strength] || 1.0;
      
      totalCost += baseCost * strengthMultiplier;
    }
    
    return totalCost;
  }
  
  /**
   * 计算可靠性分数
   */
  calculateReliabilityScore(combination) {
    let score = 100;
    
    for (const selection of combination) {
      switch (selection.match_strength) {
        case 'high': score += 15; break;
        case 'medium': score += 10; break;
        case 'low': score += 5; break;
      }
    }
    
    return Math.max(0, Math.min(100, score));
  }
  
  /**
   * 获取推荐的配置方案
   */
  async getRecommendedConfigurations(productId, targetPartIds, criteria = {}) {
    const {
      maxCost = Infinity,
      minReliability = 0,
      limit = 10
    } = criteria;
    
    const configurations = await this.generateConfigurations(productId, targetPartIds);
    
    // 过滤配置
    const filteredConfigurations = configurations.available_configurations
      .filter(config => 
        config.estimated_cost <= maxCost && 
        config.reliability_score >= minReliability
      )
      .slice(0, limit);
    
    return {
      ...configurations,
      available_configurations: filteredConfigurations,
      filter_criteria: criteria
    };
  }
  
  /**
   * 生成配置报告
   */
  async generateConfigurationReport(productId, targetPartIds) {
    const configurations = await this.generateConfigurations(productId, targetPartIds);
    
    const report = {
      ...configurations,
      summary: {
        total_target_parts: targetPartIds.length,
        generation_time: new Date(),
        analysis: this.analyzeConfigurations(configurations)
      }
    };
    
    return report;
  }
  
  /**
   * 分析配置数据
   */
  analyzeConfigurations(configurations) {
    const analysis = {
      best_configuration: configurations.available_configurations[0] || null,
      cost_range: {
        min: Infinity,
        max: -Infinity,
        average: 0
      },
      reliability_range: {
        min: Infinity,
        max: -Infinity,
        average: 0
      }
    };
    
    if (configurations.available_configurations.length > 0) {
      let totalCost = 0;
      let totalReliability = 0;
      
      for (const config of configurations.available_configurations) {
        analysis.cost_range.min = Math.min(analysis.cost_range.min, config.estimated_cost);
        analysis.cost_range.max = Math.max(analysis.cost_range.max, config.estimated_cost);
        analysis.reliability_range.min = Math.min(analysis.reliability_range.min, config.reliability_score);
        analysis.reliability_range.max = Math.max(analysis.reliability_range.max, config.reliability_score);
        
        totalCost += config.estimated_cost;
        totalReliability += config.reliability_score;
      }
      
      analysis.cost_range.average = totalCost / configurations.available_configurations.length;
      analysis.reliability_range.average = totalReliability / configurations.available_configurations.length;
    }
    
    return analysis;
  }
}

module.exports = new ConfigurationGenerator();